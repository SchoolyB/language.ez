---
import BaseLayout from './BaseLayout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import Sidebar from '../components/Sidebar.astro';
import TableOfContents from '../components/TableOfContents.astro';

interface Props {
  title?: string;
  description?: string;
  frontmatter?: {
    title: string;
    description?: string;
  };
}

// Support both direct props (Astro) and frontmatter (MDX)
const { frontmatter } = Astro.props;
const title = Astro.props.title || frontmatter?.title || 'Documentation';
const description = Astro.props.description || frontmatter?.description;
---

<BaseLayout title={`${title} - EZ Docs`} description={description}>
  <Header />

  <div class="flex-1 max-w-[90rem] mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="flex gap-8">
      <Sidebar />

      <main class="flex-1 min-w-0">
        <article class="docs-content max-w-3xl">
          <slot />
        </article>
      </main>

      <TableOfContents />
    </div>
  </div>

  <Footer />
</BaseLayout>

<script>
  // Bash/Shell syntax highlighter
  function highlightBash(code: string): string {
    // Common shell commands
    const commands = [
      'cd', 'ls', 'mv', 'cp', 'rm', 'mkdir', 'rmdir', 'touch', 'cat', 'echo',
      'grep', 'find', 'sed', 'awk', 'tar', 'gzip', 'gunzip', 'zip', 'unzip',
      'chmod', 'chown', 'sudo', 'su', 'apt', 'apt-get', 'yum', 'brew', 'npm',
      'git', 'make', 'curl', 'wget', 'ssh', 'scp', 'man', 'which', 'whereis',
      'export', 'source', 'alias', 'unalias', 'set', 'unset', 'env',
      'ez', 'go', 'node', 'python', 'pip', 'cargo', 'rustc'
    ];

    let result = code;
    const markers: { marker: string; replacement: string }[] = [];
    let markerIndex = 0;

    const createMarker = (content: string, className: string): string => {
      const marker = `__BASH_MARKER_${markerIndex++}__`;
      const escaped = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      markers.push({ marker, replacement: `<span class="${className}">${escaped}</span>` });
      return marker;
    };

    // Extract comments first
    result = result.replace(/(#.*$)/gm, (match) => createMarker(match, 'bash-comment'));

    // Extract double-quoted strings
    result = result.replace(/("(?:[^"\\]|\\.)*")/g, (match) => createMarker(match, 'bash-string'));

    // Extract single-quoted strings
    result = result.replace(/('(?:[^'\\]|\\.)*')/g, (match) => createMarker(match, 'bash-string'));

    // Extract variables ${VAR} and $VAR
    result = result.replace(/(\$\{[^}]+\}|\$[A-Za-z_][A-Za-z0-9_]*)/g, (match) => createMarker(match, 'bash-variable'));

    // Escape remaining HTML
    result = result.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Highlight flags (--flag, -f) - must come before commands
    result = result.replace(/(--?[A-Za-z][A-Za-z0-9-]*)/g, '<span class="bash-flag">$1</span>');

    // Highlight commands at start of line or after && || | ;
    commands.forEach(cmd => {
      // At start of line
      const startRegex = new RegExp(`^(${cmd})\\b`, 'gm');
      result = result.replace(startRegex, '<span class="bash-command">$1</span>');
      // After operators
      const afterOpRegex = new RegExp(`(&&|\\|\\||\\||;)\\s*(${cmd})\\b`, 'g');
      result = result.replace(afterOpRegex, '$1 <span class="bash-command">$2</span>');
    });

    // Restore markers
    markers.forEach(({ marker, replacement }) => {
      result = result.replace(marker, replacement);
    });

    return result;
  }

  // Comprehensive EZ syntax highlighter - same logic as CodeBlock component
  function highlightEZ(code: string): string {
    // All EZ keywords
    const keywords = [
      'temp', 'const', 'do', 'if', 'or', 'otherwise',
      'for', 'for_each', 'as_long_as', 'loop', 'return',
      'import', 'using', 'module', 'in', 'break', 'continue',
      'struct', 'enum', 'priv'
    ];

    // All types including sized integers
    const types = [
      'int', 'float', 'string', 'bool', 'void', 'any', 'char', 'map',
      'i8', 'u8', 'i16', 'u16', 'i32', 'u32', 'i64', 'u64', 'i128', 'u128', 'i256', 'u256'
    ];

    // Built-in functions
    const builtins = ['println', 'print', 'len', 'append', 'range', 'typeof'];

    // Type conversion functions
    const typeConversions = ['int', 'float', 'string'];

    let result = code;
    const markers: { marker: string; replacement: string }[] = [];
    let markerIndex = 0;

    const createMarker = (content: string, className: string): string => {
      const marker = `__EZ_MARKER_${markerIndex++}__`;
      const escaped = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      markers.push({ marker, replacement: `<span class="${className}">${escaped}</span>` });
      return marker;
    };

    // Extract multi-line comments first
    result = result.replace(/(\/\*[\s\S]*?\*\/)/g, (match) => createMarker(match, 'ez-comment'));
    // Extract single-line comments
    result = result.replace(/(\/\/.*$)/gm, (match) => createMarker(match, 'ez-comment'));
    // Extract strings (double quotes)
    result = result.replace(/("(?:[^"\\]|\\.)*")/g, (match) => createMarker(match, 'ez-string'));
    // Extract single-char strings (single quotes)
    result = result.replace(/('(?:[^'\\]|\\.)')/g, (match) => createMarker(match, 'ez-string'));

    // Extract import statements with @ - handle alias@module and @module patterns
    // Pattern: alias@module (e.g., arr@arrays, m@math)
    result = result.replace(/\b(\w+)(@)(\w+)\b/g, (match, alias, at, moduleName) => {
      const aliasMarker = createMarker(alias, 'ez-module');
      const atMarker = createMarker(at, 'ez-operator');
      const moduleMarker = createMarker(moduleName, 'ez-module');
      return aliasMarker + atMarker + moduleMarker;
    });

    // Pattern: @module (e.g., @std, @math, @arrays)
    result = result.replace(/(@)(\w+)/g, (match, at, moduleName) => {
      const atMarker = createMarker(at, 'ez-operator');
      const moduleMarker = createMarker(moduleName, 'ez-module');
      return atMarker + moduleMarker;
    });

    // Extract & operator in "import & use"
    result = result.replace(/\b(import)\s+(&)\s+(use)\b/g, (match, imp, amp, use) => {
      const impMarker = createMarker(imp, 'ez-keyword');
      const ampMarker = createMarker(amp, 'ez-operator');
      const useMarker = createMarker(use, 'ez-keyword');
      return impMarker + ' ' + ampMarker + ' ' + useMarker;
    });

    // Escape remaining HTML
    result = result.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Booleans
    result = result.replace(/\b(true|false)\b/g, '<span class="ez-boolean">$1</span>');

    // Numbers
    result = result.replace(/\b(\d+\.?\d*)\b/g, '<span class="ez-number">$1</span>');

    // Keywords
    keywords.forEach(kw => {
      const regex = new RegExp(`\\b(${kw})\\b`, 'g');
      result = result.replace(regex, '<span class="ez-keyword">$1</span>');
    });

    // Types (but not when used as function calls like int(), float(), string())
    types.forEach(t => {
      const regex = new RegExp(`\\b(${t})\\b(?!\\()`, 'g');
      result = result.replace(regex, '<span class="ez-type">$1</span>');
    });

    // Type conversion functions when followed by (
    typeConversions.forEach(fn => {
      const regex = new RegExp(`\\b(${fn})(?=\\()`, 'g');
      result = result.replace(regex, '<span class="ez-function">$1</span>');
    });

    // Builtins
    builtins.forEach(fn => {
      const regex = new RegExp(`\\b(${fn})(?=\\()`, 'g');
      result = result.replace(regex, '<span class="ez-function">$1</span>');
    });

    // Restore markers
    markers.forEach(({ marker, replacement }) => {
      result = result.replace(marker, replacement);
    });

    return result;
  }

  function initDocsCodeBlocks() {
    // Apply syntax highlighting to code blocks
    const bashLanguages = ['bash', 'shell', 'sh', 'powershell', 'ps1'];
    const skipLanguages = ['javascript', 'js', 'typescript', 'ts', 'json', 'html', 'css'];

    const allCodeBlocks = document.querySelectorAll('.docs-content pre code');
    allCodeBlocks.forEach((codeEl) => {
      if (codeEl.getAttribute('data-highlighted')) return;

      // Check language
      const classList = Array.from(codeEl.classList);
      const langClass = classList.find(c => c.startsWith('language-'));
      const lang = langClass?.replace('language-', '') || '';

      const originalCode = codeEl.textContent || '';

      if (bashLanguages.includes(lang)) {
        // Apply bash highlighting
        codeEl.innerHTML = highlightBash(originalCode);
        codeEl.setAttribute('data-highlighted', 'bash');
      } else if (skipLanguages.includes(lang)) {
        // Skip these languages entirely
        return;
      } else {
        // Apply EZ highlighting (default)
        codeEl.innerHTML = highlightEZ(originalCode);
        codeEl.setAttribute('data-highlighted', 'ez');
      }
    });

    // Add copy buttons to all code blocks
    const codeBlocks = document.querySelectorAll('.docs-content pre');
    codeBlocks.forEach((pre) => {
      if (pre.parentElement?.classList.contains('code-block-wrapper')) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'code-block-wrapper';
      pre.parentNode?.insertBefore(wrapper, pre);
      wrapper.appendChild(pre);

      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.type = 'button';

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code')?.textContent || pre.textContent || '';
        try {
          await navigator.clipboard.writeText(code);
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = 'Copy';
            button.classList.remove('copied');
          }, 2000);
        } catch (err) {
          button.textContent = 'Failed';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        }
      });

      wrapper.appendChild(button);
    });
  }

  initDocsCodeBlocks();
  document.addEventListener('astro:after-swap', initDocsCodeBlocks);
</script>
