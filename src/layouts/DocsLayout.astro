---
import BaseLayout from './BaseLayout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import Sidebar from '../components/Sidebar.astro';
import TableOfContents from '../components/TableOfContents.astro';

interface Props {
  title?: string;
  description?: string;
  frontmatter?: {
    title: string;
    description?: string;
  };
}

// Support both direct props (Astro) and frontmatter (MDX)
const { frontmatter } = Astro.props;
const title = Astro.props.title || frontmatter?.title || 'Documentation';
const description = Astro.props.description || frontmatter?.description;
---

<BaseLayout title={`${title} - EZ Docs`} description={description}>
  <Header />

  <div class="flex-1 max-w-[90rem] mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="flex gap-8">
      <Sidebar />

      <main class="flex-1 min-w-0">
        <article class="docs-content max-w-3xl">
          <slot />
        </article>
      </main>

      <TableOfContents />
    </div>
  </div>

  <Footer />
</BaseLayout>

<script>
  // Bash/Shell syntax highlighter
  function highlightBash(code: string): string {
    // Common shell commands
    const commands = [
      'cd', 'ls', 'mv', 'cp', 'rm', 'mkdir', 'rmdir', 'touch', 'cat', 'echo',
      'grep', 'find', 'sed', 'awk', 'tar', 'gzip', 'gunzip', 'zip', 'unzip',
      'chmod', 'chown', 'sudo', 'su', 'apt', 'apt-get', 'yum', 'brew', 'npm',
      'git', 'make', 'curl', 'wget', 'ssh', 'scp', 'man', 'which', 'whereis',
      'export', 'source', 'alias', 'unalias', 'set', 'unset', 'env',
      'ez', 'go', 'node', 'python', 'pip', 'cargo', 'rustc'
    ];

    let result = code;
    const markers: { marker: string; replacement: string }[] = [];
    let markerIndex = 0;

    const createMarker = (content: string, className: string): string => {
      const marker = `__BASH_MARKER_${markerIndex++}__`;
      const escaped = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      markers.push({ marker, replacement: `<span class="${className}">${escaped}</span>` });
      return marker;
    };

    // Extract comments first
    result = result.replace(/(#.*$)/gm, (match) => createMarker(match, 'bash-comment'));

    // Extract double-quoted strings
    result = result.replace(/("(?:[^"\\]|\\.)*")/g, (match) => createMarker(match, 'bash-string'));

    // Extract single-quoted strings
    result = result.replace(/('(?:[^'\\]|\\.)*')/g, (match) => createMarker(match, 'bash-string'));

    // Extract variables ${VAR} and $VAR
    result = result.replace(/(\$\{[^}]+\}|\$[A-Za-z_][A-Za-z0-9_]*)/g, (match) => createMarker(match, 'bash-variable'));

    // Escape remaining HTML
    result = result.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Highlight flags (--flag, -f) - must come before commands
    result = result.replace(/(--?[A-Za-z][A-Za-z0-9-]*)/g, '<span class="bash-flag">$1</span>');

    // Highlight commands at start of line or after && || | ;
    commands.forEach(cmd => {
      // At start of line
      const startRegex = new RegExp(`^(${cmd})\\b`, 'gm');
      result = result.replace(startRegex, '<span class="bash-command">$1</span>');
      // After operators
      const afterOpRegex = new RegExp(`(&&|\\|\\||\\||;)\\s*(${cmd})\\b`, 'g');
      result = result.replace(afterOpRegex, '$1 <span class="bash-command">$2</span>');
    });

    // Restore markers
    markers.forEach(({ marker, replacement }) => {
      result = result.replace(marker, replacement);
    });

    return result;
  }

  // Comprehensive EZ syntax highlighter - same logic as CodeBlock component
  function highlightEZ(code: string): string {
    // All EZ keywords
    const keywords = [
      'temp', 'const', 'do', 'if', 'or', 'otherwise',
      'for', 'for_each', 'as_long_as', 'loop', 'return',
      'import', 'using', 'module', 'in', 'break', 'continue',
      'struct', 'enum', 'priv'
    ];

    // All types including sized integers
    const types = [
      'int', 'float', 'string', 'bool', 'void', 'any', 'char', 'map',
      'i8', 'u8', 'i16', 'u16', 'i32', 'u32', 'i64', 'u64', 'i128', 'u128', 'i256', 'u256'
    ];

    // Built-in functions
    const builtins = ['println', 'print', 'len', 'append', 'range', 'typeof'];

    // Type conversion functions
    const typeConversions = ['int', 'float', 'string'];

    let result = code;
    const markers: { marker: string; replacement: string }[] = [];
    let markerIndex = 0;

    const createMarker = (content: string, className: string): string => {
      const marker = `__EZ_MARKER_${markerIndex++}__`;
      const escaped = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      markers.push({ marker, replacement: `<span class="${className}">${escaped}</span>` });
      return marker;
    };

    // Extract multi-line comments first
    result = result.replace(/(\/\*[\s\S]*?\*\/)/g, (match) => createMarker(match, 'ez-comment'));
    // Extract single-line comments
    result = result.replace(/(\/\/.*$)/gm, (match) => createMarker(match, 'ez-comment'));
    // Extract strings (double quotes)
    result = result.replace(/("(?:[^"\\]|\\.)*")/g, (match) => createMarker(match, 'ez-string'));
    // Extract single-char strings (single quotes)
    result = result.replace(/('(?:[^'\\]|\\.)')/g, (match) => createMarker(match, 'ez-string'));

    // Extract import statements with @ - handle alias@module and @module patterns
    // Pattern: alias@module (e.g., arr@arrays, m@math)
    result = result.replace(/\b(\w+)(@)(\w+)\b/g, (match, alias, at, moduleName) => {
      const aliasMarker = createMarker(alias, 'ez-module');
      const atMarker = createMarker(at, 'ez-operator');
      const moduleMarker = createMarker(moduleName, 'ez-module');
      return aliasMarker + atMarker + moduleMarker;
    });

    // Pattern: @module (e.g., @std, @math, @arrays)
    result = result.replace(/(@)(\w+)/g, (match, at, moduleName) => {
      const atMarker = createMarker(at, 'ez-operator');
      const moduleMarker = createMarker(moduleName, 'ez-module');
      return atMarker + moduleMarker;
    });

    // Extract & operator in "import & use"
    result = result.replace(/\b(import)\s+(&)\s+(use)\b/g, (match, imp, amp, use) => {
      const impMarker = createMarker(imp, 'ez-keyword');
      const ampMarker = createMarker(amp, 'ez-operator');
      const useMarker = createMarker(use, 'ez-keyword');
      return impMarker + ' ' + ampMarker + ' ' + useMarker;
    });

    // Escape remaining HTML
    result = result.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Booleans
    result = result.replace(/\b(true|false)\b/g, '<span class="ez-boolean">$1</span>');

    // Numbers
    result = result.replace(/\b(\d+\.?\d*)\b/g, '<span class="ez-number">$1</span>');

    // Keywords
    keywords.forEach(kw => {
      const regex = new RegExp(`\\b(${kw})\\b`, 'g');
      result = result.replace(regex, '<span class="ez-keyword">$1</span>');
    });

    // Types (but not when used as function calls like int(), float(), string())
    types.forEach(t => {
      const regex = new RegExp(`\\b(${t})\\b(?!\\()`, 'g');
      result = result.replace(regex, '<span class="ez-type">$1</span>');
    });

    // Type conversion functions when followed by (
    typeConversions.forEach(fn => {
      const regex = new RegExp(`\\b(${fn})(?=\\()`, 'g');
      result = result.replace(regex, '<span class="ez-function">$1</span>');
    });

    // Builtins
    builtins.forEach(fn => {
      const regex = new RegExp(`\\b(${fn})(?=\\()`, 'g');
      result = result.replace(regex, '<span class="ez-function">$1</span>');
    });

    // Restore markers
    markers.forEach(({ marker, replacement }) => {
      result = result.replace(marker, replacement);
    });

    return result;
  }

  function initDocsCodeBlocks() {
    // Apply syntax highlighting to code blocks
    const bashLanguages = ['bash', 'shell', 'sh', 'powershell', 'ps1'];
    const skipLanguages = ['javascript', 'js', 'typescript', 'ts', 'json', 'html', 'css'];

    const allCodeBlocks = document.querySelectorAll('.docs-content pre code');
    allCodeBlocks.forEach((codeEl) => {
      if (codeEl.getAttribute('data-highlighted')) return;

      // Check language
      const classList = Array.from(codeEl.classList);
      const langClass = classList.find(c => c.startsWith('language-'));
      const lang = langClass?.replace('language-', '') || '';

      const originalCode = codeEl.textContent || '';

      if (bashLanguages.includes(lang)) {
        // Apply bash highlighting
        codeEl.innerHTML = highlightBash(originalCode);
        codeEl.setAttribute('data-highlighted', 'bash');
      } else if (skipLanguages.includes(lang)) {
        // Skip these languages entirely
        return;
      } else {
        // Apply EZ highlighting (default)
        codeEl.innerHTML = highlightEZ(originalCode);
        codeEl.setAttribute('data-highlighted', 'ez');
      }
    });

    // Add copy buttons to all code blocks
    const codeBlocks = document.querySelectorAll('.docs-content pre');
    codeBlocks.forEach((pre) => {
      if (pre.parentElement?.classList.contains('code-block-wrapper')) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'code-block-wrapper';
      pre.parentNode?.insertBefore(wrapper, pre);
      wrapper.appendChild(pre);

      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.type = 'button';

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code')?.textContent || pre.textContent || '';
        try {
          await navigator.clipboard.writeText(code);
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = 'Copy';
            button.classList.remove('copied');
          }, 2000);
        } catch (err) {
          button.textContent = 'Failed';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        }
      });

      wrapper.appendChild(button);
    });
  }

  // Fuzzy search for stdlib pages
  function fuzzyMatch(text: string, query: string): boolean {
    text = text.toLowerCase();
    query = query.toLowerCase();

    // Exact substring match
    if (text.includes(query)) return true;

    // Fuzzy match: all query chars appear in order
    let textIndex = 0;
    for (const char of query) {
      const foundIndex = text.indexOf(char, textIndex);
      if (foundIndex === -1) return false;
      textIndex = foundIndex + 1;
    }
    return true;
  }

  function initStdlibSearch() {
    // Only run on stdlib pages
    if (!window.location.pathname.includes('/docs/stdlib/')) return;

    const docsContent = document.querySelector('.docs-content');
    if (!docsContent) return;

    // Check if search already exists
    if (document.querySelector('.stdlib-search')) return;

    // Find h1 and insert search after it
    const h1 = docsContent.querySelector('h1');
    if (!h1) return;

    // Create search container
    const searchContainer = document.createElement('div');
    searchContainer.className = 'stdlib-search';
    searchContainer.innerHTML = `
      <input type="text" class="stdlib-search-input" placeholder="Search functions..." />
      <span class="stdlib-search-count"></span>
    `;

    h1.insertAdjacentElement('afterend', searchContainer);

    const searchInput = searchContainer.querySelector('.stdlib-search-input') as HTMLInputElement;
    const searchCount = searchContainer.querySelector('.stdlib-search-count') as HTMLSpanElement;

    // Get all function sections (h3 headings and their content)
    const sections: { heading: Element; elements: Element[] }[] = [];
    let currentSection: { heading: Element; elements: Element[] } | null = null;

    // Walk through all elements after h1
    let sibling = searchContainer.nextElementSibling;
    while (sibling) {
      if (sibling.tagName === 'H2') {
        // H2 marks a new category, save current section
        if (currentSection) sections.push(currentSection);
        currentSection = null;
        // H2s are always visible
        sibling = sibling.nextElementSibling;
        continue;
      }

      if (sibling.tagName === 'H3') {
        // Save previous section
        if (currentSection) sections.push(currentSection);
        // Start new section
        currentSection = { heading: sibling, elements: [] };
      } else if (currentSection) {
        // Add element to current section
        currentSection.elements.push(sibling);
      }

      sibling = sibling.nextElementSibling;
    }
    // Don't forget last section
    if (currentSection) sections.push(currentSection);

    // Search handler
    searchInput.addEventListener('input', () => {
      const query = searchInput.value.trim();

      if (!query) {
        // Show all sections
        sections.forEach(section => {
          (section.heading as HTMLElement).style.display = '';
          section.elements.forEach(el => (el as HTMLElement).style.display = '');
        });
        searchCount.textContent = '';
        return;
      }

      let visibleCount = 0;

      sections.forEach(section => {
        const headingText = section.heading.textContent || '';
        const matches = fuzzyMatch(headingText, query);

        if (matches) {
          (section.heading as HTMLElement).style.display = '';
          section.elements.forEach(el => (el as HTMLElement).style.display = '');
          visibleCount++;
        } else {
          (section.heading as HTMLElement).style.display = 'none';
          section.elements.forEach(el => (el as HTMLElement).style.display = 'none');
        }
      });

      searchCount.textContent = `${visibleCount} of ${sections.length}`;
    });
  }

  initDocsCodeBlocks();
  initStdlibSearch();
  document.addEventListener('astro:after-swap', () => {
    initDocsCodeBlocks();
    initStdlibSearch();
  });
</script>
