/*
 * mutable_params.ez - Mutable vs Read-Only Parameters
 *
 * By default, function parameters are read-only.
 * Use & to allow a function to modify its parameter.
 */

import @std
using std

const Person struct {
    name string
    age int
}

do main() {
    println("=== Mutable Parameters ===")
    println("")

    // Create a person
    temp alice Person = Person{name: "Alice", age: 30}
    println("Initial: ${alice.name} is ${alice.age}")

    // Read-only: get_info just reads the data
    temp info string = get_info(alice)
    println("Info: ${info}")

    // Mutable: birthday modifies the person
    birthday(&alice)
    println("After birthday: ${alice.name} is ${alice.age}")

    // Another birthday
    birthday(&alice)
    println("After another birthday: ${alice.name} is ${alice.age}")

    // Arrays work the same way
    println("")
    println("-- Arrays --")
    temp scores [int] = {85, 90, 78}
    println("Before: ${scores}")

    // Mutable: add_bonus modifies the array
    add_bonus(&scores, 5)
    println("After +5 bonus: ${scores}")

    // Read-only: calculate_average just reads
    temp avg float = calculate_average(scores)
    println("Average: ${avg}")
}

// Read-only parameter (no &)
// Can read p but cannot modify it
do get_info(p Person) -> string {
    // p.age = 100  // ERROR: cannot modify read-only parameter
    return "${p.name}, age ${p.age}"
}

// Mutable parameter (with &)
// Can modify p
do birthday(&p Person) {
    p.age = p.age + 1
}

// Read-only array parameter
do calculate_average(nums [int]) -> float {
    temp sum int = 0
    for_each n in nums {
        sum = sum + n
    }
    return float(sum) / float(len(nums))
}

// Mutable array parameter
do add_bonus(&scores [int], bonus int) {
    for i in range(0, len(scores)) {
        scores[i] = scores[i] + bonus
    }
}
